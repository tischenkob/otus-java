```
java --version
openjdk 11.0.10 2021-01-19
```

| Параметр              | G1 (128M) | ZGC (128M)    | G1 (2G)   | ZGC (2G)  |
| :---                  |    :----: |    :----:     | :----:    | :----:    |
| Время работы          | 17s       | 1s            | 4m13s     | 4m36s     |
| Накопл. паузы         | 2.21s     | 0.02s         | 43.63s    | 0.04s     |
| Throughput            | 87.1%     | 98.94%        | 82.8%     | 99.99%    |
| Число остановок       | 133       | 20            | 109       | 41        |
| Полных остановок      | 14        | 0             | 24        | 0         |

Для получения сведённых данных использован GCViewer.

# Прогон первый (G1, ZGC)

В моем случае разница между сборщиками выглядит огромной. 
У меня есть несколько вариантов, что на это могло повлиять:
- недостаток оперативной памяти
- запуск приложения в Windows Subsystem for Linux
- другие возможные технические неполадки
- неисправный плагин для анализа логов

С другой стороны, здесь не учитывается вес структур, которые
используются сборщиком мусора.  
Но по текущим результатам видно следующее: с большой кучей ZGC справляется гораздо лучше G1, это ярко видно по всем параметрам, особенно по накопленным паузам. Время работы показывает, что приложение упало позже, что тоже хорошо.  
На маленьком хипе (128М) приложение с ZGC проработало всего одну секунду и упало. Это делает его использование невозможным на системах с ограниченным размером оперативной памяти. Хотя это тоже могло быть вызвано моими проблемами с RAM, а также тем, что в JDK11 этот сборщик являлся экспериментальным.

**Вывод:** для приложений с маленьким размером кучи и нестрогими требованиями к throughput G1 является лучшим выбором. Для большой кучи и жестких требований по простоям и отзывчивости приложения ZGC явно выигрывает.

# Прогон второй (+ParallelGC, +полезные циклы, другая система)

*Для 2Гб цикл количество создаваемых объектов в цикле увеличено до миллиона, потому что OoM Error не вылетела даже спустя 40 минут*

| Параметр              | G1 (128M) | ZGC (128M)    | ParallelGC (128M)     | G1 (2G)   | ZGC (2G)  | ParallelGC (2G)   |
| :---                  |   :----:  |    :----:     |    :----:             | :----:    | :----:    |      :----:       |
| Время работы          | 9s        | N/A           | 9s                    | 9m30s     | 6m        | 2m34s             |
| Накопл. паузы         | 2.44s     | 0s            | 6.12s                 | 37.55s    | 0.01s     | 14.04s            |
| Throughput            | 74.93%    | 99.75%        | 38.64%                | 93.42%    | 100%      | 90.89%            |
| Число остановок       | 65        | 6             | 11                    | 58        | 27        | 6                 |
| Полных остановок      | 19        | 0             | 48                    | 22        | 0         | 9                 |
| Полезных циклов       | 12        | 1             | 9                     | 8         | 5         | 6                 |

Во втором прогоне на 128M G1 и ZGC показали примерно те же результаты. ParallelGC сильно уступает G1 по всем параметрам: низкая
пропускная способность, сильно больше полных остановок, меньше полезной работы.  

На 2G ParallelGC заметно приблизился к показателям G1, но все-таки остался хуже по всем показателям. Хотя удивительно, что
он выполнил 75% работы G1 за всего лишь ~четверть времени.

**Вывод:** то же самое, что после первого прогона. Что касается ParallelGC, на данном тесте не удалось найти сценариев, где
он был бы предпочтительнее G1, в то время как ZGC выполняет работу эффективнее, но радает раньше.
