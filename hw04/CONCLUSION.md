```
java --version
openjdk 11.0.10 2021-01-19
```

| Параметр              | G1 (128M) | ZGC (128M)    | G1 (2G)   | ZGC (2G)  |
| :---                  |    :----: |    :----:     | :----:    | :----:    |
| Время работы          | 17s       | 1s            | 4m13s     | 4m36s     |
| Накопл. паузы         | 2.21s     | 0.02s         | 43.63s    | 0.04s     |
| Throughput            | 87.1%     | 98.94%        | 82.8%     | 99.99%    |
| Число остановок       | 133       | 20            | 109       | 41        |
| Число полн. остановок | 14        | 0             | 24        | 0         |

Для получения сведённых данных использован GCViewer.

В моем случае разница между сборщиками выглядит огромной. 
У меня есть несколько вариантов, что на это могло повлиять:
- недостаток оперативной памяти
- запуск приложения в Windows Subsystem for Linux
- другие возможные технические неполадки
- неисправный плагин для анализа логов

С другой стороны, здесь не учитывается вес структур, которые
используются сборщиком мусора.  
Но по текущим результатам видно следующее: с большой кучей ZGC справляется гораздо лучше G1, это ярко видно по всем параметрам, особенно по накопленным паузам. Время работы показывает, что приложение упало позже, что тоже хорошо.  
На маленьком хипе (128М) приложение с ZGC проработало всего одну секунду и упало. Это делает его использование невозможным на системах с ограниченным размером оперативной памяти. Хотя это тоже могло быть вызвано моими проблемами с RAM, а также тем, что в JDK11 этот сборщик являлся экспериментальным.

**Вывод:** для приложений с маленьким размером кучи и нестрогими требованиями к throughput G1 является лучшим выбором. Для большой кучи и жесткими требованиями к простоям и отзывчивости приложения ZGC явно выигрывает.